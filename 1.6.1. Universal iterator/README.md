## 1.6.1. Универсальный итератор

У Go удобный синтаксис итерирования по срезам:

```Go
for idx, elem := range slice {
    // do stuff
}
```

Но бывает, что есть не чистый срез, а другой объект, который включает последовательность элементов:

* файл (последовательность — строки);
* таблица базы данных (последовательность — записи);
* API поиска (последовательность — страницы с результатами).

Удобно было бы работать с такими последовательностями единообразно, через _итератор_. Вот так:

```Go
func iterate(it iterator) {
    for it.next() {
        curr := it.val()
        fmt.Println(curr)
    }
}
```

Определите интерфейс `iterator`, который содержит необходимые методы. Реализовывать интерфейс в конкретном типе не надо — этим займемся в следующем задании.

___
**Напишите программу. Тестируется через stdin → stdout**

**Time Limit:** 8 секунд

**Memory Limit:** 256 MB
___
**Sample Input:**
> **1 2 3 4 5**

**Sample Output:**
> **1
2
3
4
5**
___

```Go
package main

import (
    "fmt"
)

// element - интерфейс элемента последовательности
// (пустой, потому что элемент может быть любым).
type element interface{}

// iterator - интерфейс, который умеет
// поэлементно перебирать последовательность
type iterator interface {
    // определите методы итератора
    // чтобы понять сигнатуры методов - посмотрите,
    // как они используются в функции iterate() ниже
}

// iterate обходит последовательность
// и печатает каждый элемент
func iterate(it iterator) {
    for it.next() {
        curr := it.val()
        fmt.Println(curr)
    }
}

// в этом задании функция main() определена "за кадром",
// не добавляйте ее
```